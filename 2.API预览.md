#MobX Api 参考

##主要API
理解`observable`,`computed`,`reactions`和`actions`，对于在应用中使用MobX已经足够了。

##创建observables

###`obsevable`
使用
* `obsevable(value)`
* `@observable classProperty = value`

被观察的值可以是js元素，引用，对象，实例，数组。应用下面的规则，可以通过修饰符进行修改。见下文。

1.如果值在修饰符`asMap`：会返回一个新的[`Observable Map`]()。如果不只是响应入口文件的修改操作，还可以响应添加和删除操作，可以使用`Observable maps`。
2.如果值是一个数组，会返回一个新的[`Observable Array`]()。
3.如果值是一个没有原型的对象，它当前的所有属性将被observable(响应?)。详细请看[`Obsevable Object`]();
4.如果值是一个具有原型的对象、元素或者是函数，将会返回一个[`Boxed Observable`]()。MobX不会在原型上自动修改，它会在构造函数中进行。在构造函数中使用`extendObservable`，或者在类中定义`@observable`

第一次看这些规则会觉得复杂，但是在实践中会非常直观。一些提示：
* 在动态创建对象的时候请使用`asMap`修饰符！尽管通过`extendObservable`可以添加一个新的值，但是只有初始化的属性才会被observable(响应)。
* 使用`@observable`装饰器。查看编译器是否支持[装饰器语法]().
* 默认情况下，对数据结构使用observable是具有感染性的；这意味着`observable`被自动应用到数据结构中的任何值，或者是在之后将被数据结构所包含。这个行为可以通过修饰符进行修改。

###`extendObservable`
使用：
`extendObservable(target,propertyMap)`
每次在`propertyMap`中设置一个键值对，就会在创建target 的对象中创建一个新的observable。这样可以在不创建装饰器的情况下，通过构造函数中引用可观察属性。如果propertyMap的值是无参数函数，则将引入计算的属性。[《细节》]();


###`Computed values`
使用：
* `computed(()=>expression())`
* `@computed get classProperty(){return expression;}`

创建一个计算属性。`expression`应该不被影响的并且返回一个值。只有当它被一些reaction使用时，观察的对象发生变化的时候，expression会自动计算。[《细节》]();


###`Actions`
任何应用都会有actions.actions是任何修改状态的东西。

通过使用MobX,你可以在代码中通过标记显示地操作。actions可以帮助你更好的组织代码结构。建议在修改包含可观察的值或者具有一定影响的函数时使用action.`action`结合devtools，可以提供错误信息的抛出。
注意：当使用严格模式的时候，使用`action`是必须的。[《细节》]();
使用：
* `actions(fn)`
* `actions(name,fn)`
* `@action classMethod`
* `@action(name) classMethod`
* `@action boundClassMethod = (args)=> {body}`
* `@action(name) boundClassMethod=(args)=>{body}`

对于只执行一次的`runInAction(name?,fn,scope?)`,它的语法糖是`action(name,fn,scope)()`;

###`Reactions`
计算出来的值（Computed values）是自动对状态变化做出响应的值。Reactions是状态变化后进行响应的同时进行另外一些操作。Reactions可以用于确保在相关状态改变时自动执行例如打印日志和获取网络数据的一些操作。最常用的是在对React component使用`observer`装饰器。

####`observer`
可以像使用高阶函数那样把React component包含起来。在被包含的组件中，当那些被观察的值在render函数中发生改变，组件将会自动重新渲染。注意：`observer`是在`"mobx-react"`中的，不是在`"mobx"`中的。[《细节》]();

使用：
* `observer(React.creatClass({...}))`
* `observer((props,context)=>ReactElemet)`
* `observer(class MyComponet extends React.Component{...})`
* `@observer class MyComponent extends React.Component{...}`

####`autorun`
使用：`aurotun(debugname?,()=>{sideEffect})`。自动运行（autorun）会执行	`sideEffect`并且在执行的时候跟踪访问可观察的状态。每次observable中的值发生变化，同样的sideEffect将会再次执行。可以返回一个处理函数来取消sideEffect。[《细节》]();

####`when`
使用：`when(debugname?,()=>condition,()=>{sideEffect})`
条件表达式（condition）将自动对其使用的任何observable进行响应。一旦表达式返回true，sideEffect函数将被调用，但只有一次。`when`返回一个处理函数可以提前取消整个事件的执行。[《细节》]();

####`autorunAsync`
使用：`autorunAsync(debugname?,()=>{sideEffect},delay)`
和`autorun`类似，但是sideEffect会延迟执行，并且会依照给的`delay`值延期执行。[《细节》]();

####`reaction`
使用：`reaction(debugname?,()=>data,data=>{sideEffect},fireImmediately=false,delay=0)`
是`autorun`的一个变体，它对要跟踪可观察的值提供更细颗粒度的控制。他需要两个函数，第一个被追踪并返回的数据将会被用作第二个函数输入的数据。和`autorun`不一样，sideEffect不会一开始就执行，并且在执行sideEffect的时候，访问的任何可观察的值都不会被追踪。sideEffect可以函数节流，就像autorunAsync一样。[《细节》]();